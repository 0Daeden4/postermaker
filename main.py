from enum import Enum
from PIL import ImageDraw, ImageOps, ImageFont, Image
from argparse import ArgumentParser, Namespace
from pathlib import Path
from dataclasses import dataclass
import re
import qrcode
from qrcode.constants import ERROR_CORRECT_M
import svgwrite
import base64
import mimetypes
from io import BytesIO


@dataclass
class EventInformation():
    title: tuple[str, str, int]
    desc: tuple[str, str, int]
    place: tuple[str, str, int]
    date: tuple[str, str, int]


class Posts(Enum):
    IG_POST = (1080, 1350)
    IG_STORY = (1080, 1920)
    IG_REELS = (1080, 1920)
    FB_POST = (1200, 1200)
    FB_STORY = (1080, 1920)
    FB_REELS = (1080, 1920)
    X_POST = (1200, 675)


class PostMaker():

    def _create_gradient_map(self, length: float, canvas_size: tuple[int, int],
                             color: str) -> None:
        '''
        Not used anymore. Use _apply_gradient insted
        '''

    def _get_padding(self, canvas_type: Posts) -> tuple[int, int]:
        canvas_name = canvas_type.name
        if canvas_name == "IG_STORY" or canvas_name == "FB_STORY":
            return (100, 120)
        elif canvas_name == "IG_POST":
            return (0, 135)
        else:
            return (0, 0)

    def _embed_image(self, image: Path | bytes) -> str:
        if isinstance(image, Path):
            img = image.resolve()
            img_bytes = img.read_bytes()
            mime = mimetypes.guess_type(img)[0] or 'image/png'
        else:
            img_bytes = image
            mime = "image/png"

        return f'data:{mime};base64,' + \
            base64.b64encode(img_bytes).decode()

    def _place_bg_image(self, canvas: svgwrite.Drawing, bg_image: Path, padding: tuple[int, int]):
        c_width = float(canvas.attribs["width"])
        c_height = float(canvas.attribs["height"])
        desired_size = (c_width, c_height - (2 * padding[1]))
        canvas.add(canvas.image(href=self._embed_image(bg_image), insert=(
            0, padding[1]), size=desired_size, preserveAspectRatio="xMidYMid slice"))

    # This function was generated by AI
    def _generate_qr(self, link: str,
                     size: tuple[int, int] = (300, 300),
                     *,
                     fill: str = "black",
                     back: str = "white",
                     error=ERROR_CORRECT_M,
                     border: int = 4,
                     box_size: int = 10) -> Image.Image:

        qr = qrcode.QRCode(
            version=None,
            error_correction=error,
            box_size=box_size,
            border=border,
        )
        qr.add_data(link)
        qr.make(fit=True)

        img = qr.make_image(fill_color=fill, back_color=back).convert("RGB")

        img = img.resize(size, Image.NEAREST)
        return img

    def _place_logo(self, canvas: svgwrite.Drawing, logo_image: Image.Image, link: str):
        c_width = canvas.attribs["width"]
        c_height = canvas.attribs["height"]
        if link != "PlaceholderLink":
            qr_image = self._generate_qr(link, logo_image.size)
            temp_canvas = Image.new(
                "RGBA", ((logo_image.width*2), logo_image.height))
            temp_canvas.paste(logo_image, (logo_image.width, 0))
            temp_canvas.paste(qr_image, (0, 0))
            logo_image = temp_canvas
        if not self.place_bbox or not self.date_bbox:
            desired_size = (c_width//5, int(c_height//5.4))
        else:
            x_space = c_width - \
                int(max(self.date_bbox[2], self.place_bbox[2]) + 10)
            inverse_ratio = logo_image.height/logo_image.width
            y_space = c_height - min(self.place_bbox[1], self.place_bbox[3])
            if y_space/x_space < inverse_ratio:
                x_space = int((1/inverse_ratio) * y_space)

            y_space = x_space * inverse_ratio
            desired_size = (x_space, int(y_space))

        resized_logo_image = ImageOps.cover(logo_image, desired_size)
        buffer = BytesIO()
        resized_logo_image.save(buffer, format="PNG")
        img_bytes = buffer.getvalue()
        image = self._embed_image(img_bytes)
        # max_width = int(max(self.place_bbox[2], self.date_bbox[2]))
        # (max_width + int((c_width - max_width)/2))

        canvas.add(canvas.image(href=image, insert=(c_width-(resized_logo_image.width+5), c_height -
                   resized_logo_image.height), size=desired_size, preserveAspectRatio="xMidYMid meet"))

    def _resolve_font(self, font_path: str, font_size: int) -> ImageFont.ImageFont | ImageFont.FreeTypeFont:
        if font_path == "PlaceholderFont":
            font = ImageFont.load_default_imagefont()
        else:
            try:
                font = ImageFont.truetype(font_path, font_size)
            except:
                try:
                    font = ImageFont.load(font_path)
                except:
                    raise OSError("Font dosyası bulunamadı!")
        return font

    def _embed_font(self, canvas: svgwrite.Drawing, font_path: str | Path) -> str:

        font_path = Path(font_path)
        font_name = font_path.stem.replace(' ', '_')

        mime = mimetypes.guess_type(font_path)[0] or 'font/ttf'
        font_b64 = base64.b64encode(font_path.read_bytes()).decode()

        css_rule = (
            "@font-face{"
            f"font-family:'{font_name}';"
            f"src:url('data:{mime};base64,{font_b64}') format('truetype');"
            "}"
        )
        canvas.add(canvas.style(css_rule))

        return font_name

    def _write_with_box(self, canvas: svgwrite.Drawing, text: str, font_path: str, tex_pos: tuple[int, int],
                        color: str, font_size=20):
        text = text.replace(r'\n', '\n').replace(r'\t', '\t')
        font_family = self._embed_font(canvas, font_path)

        lines = text.splitlines()

        x, _ = tex_pos
        line_height_px = font_size * 1.0

        text_group = canvas.text("", insert=tex_pos, fill=color,
                                 font_family=font_family, font_size=f"{font_size}px")

        for i, line in enumerate(lines):
            dy = 0 if i == 0 else line_height_px
            text_group.add(canvas.tspan(line, x=[x], dy=[dy]))
        canvas.add(text_group)

    def _get_bbox(self, dummy_image: Image.Image, pos: tuple[int, int], text: str, font_path: str,
                  font_size: int) -> tuple[float, float, float, float]:

        draw = ImageDraw.Draw(dummy_image)
        font = self._resolve_font(font_path, font_size)
        text = text.replace(r'\n', '\n').replace(r'\t', '\t')
        return draw.multiline_textbbox(
            pos, text, font=font, font_size=font_size+2)

    def _write_event_info(self, canvas: svgwrite.Drawing, event_info: EventInformation, color_1: str, color_2: str, padding: tuple[int, int]):
        title, title_font, title_size = event_info.title
        place, place_font, place_size = event_info.place
        date, date_font, date_size = event_info.date
        desc, desc_font, desc_size = event_info.desc
        c_h = canvas["height"]
        p_x = padding[0]
        p_y = padding[1]
        bottom_padding = (c_h - p_y)
        left_padding = (p_x + 55)
        image_size = (canvas.attribs["width"], canvas.attribs["height"])
        dummy_image = Image.new("RGB", image_size)

        # Title preloc
        title_y = p_y + title_size
        title_loc = (left_padding, title_y)
        self.title_bbox = self._get_bbox(
            dummy_image, title_loc, title, title_font, title_size)

        # Place preloc
        place_loc = (left_padding, bottom_padding - (place_size))
        self.place_bbox = self._get_bbox(
            dummy_image, place_loc, place, place_font, place_size)

        # Date preloc
        date_loc = (left_padding, int(self.place_bbox[3] - 5))
        self.date_bbox = self._get_bbox(
            dummy_image, date_loc, date, date_font, date_size)

        bottom_delta = (c_h-25) - self.date_bbox[3]
        while bottom_delta < 0:
            place_loc = (left_padding, bottom_padding - int(
                (self.place_bbox[3] - self.place_bbox[1]) - bottom_delta))
            self.place_bbox = self._get_bbox(
                dummy_image, place_loc, place, place_font, place_size)
            date_loc = (left_padding, int(self.place_bbox[3]))
            self.date_bbox = self._get_bbox(
                dummy_image, date_loc, date, date_font, date_size)
            bottom_delta = (c_h-25) - self.date_bbox[3]

        # Compensate for conversion between PIL and svgwrite
        date_x, date_y = date_loc
        place_x, place_y = place_loc
        compensation = 45

        # Desc preloc
        desc_y = int((self.title_bbox[3] - self.title_bbox[1]) +
                     title_y + desc_size - compensation)
        desc_loc = (left_padding, desc_y)
        self.description_bbox = self._get_bbox(
            dummy_image, desc_loc, desc, desc_font, desc_size)
        # Title
        self._write_with_box(canvas, title, title_font,
                             title_loc, color_1, font_size=title_size)
        # Description
        self._write_with_box(canvas, desc, desc_font,
                             desc_loc, color_1, font_size=desc_size)
        # Place
        self._write_with_box(canvas, place, place_font,
                             (place_x, place_y + compensation), color_2, font_size=place_size)
        # Date
        self._write_with_box(canvas, date, date_font,
                             (date_x, date_y + compensation + 5), color_2, font_size=date_size)

    def _apply_gradient(self, canvas: svgwrite.Drawing, color: str, start: tuple[float, float], end: tuple[float, float], name: str) -> None:
        gradient = canvas.linearGradient(
            start=start, end=end, id=name)
        gradient['gradientUnits'] = 'userSpaceOnUse'
        gradient.add_stop_color(
            offset=0, color=color, opacity=1.0)
        gradient.add_stop_color(
            offset=1, color=color, opacity=0.0)
        canvas.defs.add(gradient)
        canvas_height = canvas.attribs["height"]
        canvas_width = canvas.attribs["width"]
        reference = f"url(#{name})"
        canvas.add(canvas.rect(insert=(0, 0), size=(
            canvas_width, canvas_height), fill=reference))

    def create(self, canvas_type: Posts, bg_color_hex: str, fg_color_hex: str,
               event_information: EventInformation, link: str,
               bg_image: Path | None = None, logo_image: Path | None = None, savedir: str = ".") -> None:

        # TODO: Check validity of hex code
        canvas_height = canvas_type.value[1]
        canvas_width = canvas_type.value[0]
        file_name = self._create_file_name(canvas_type.name, event_information)

        # TODO: fix this
        svg_canvas = svgwrite.Drawing(
            str(Path(savedir).resolve()/f"{file_name}.svg"), size=canvas_type.value)

        padding = self._get_padding(canvas_type)

        if bg_image:
            self._place_bg_image(svg_canvas, bg_image, padding)

        # Draw gradient over background image
        upper_space = (canvas_width/2, padding[1])
        lower_space = (canvas_width/2, canvas_height - padding[1])
        fade_length = (canvas_height-padding[1]) * 1.0

        self._apply_gradient(svg_canvas, fg_color_hex,
                             upper_space, (canvas_width/2, fade_length), "upper_gradient")
        self._apply_gradient(svg_canvas, bg_color_hex,
                             lower_space, (canvas_width/2, canvas_height - fade_length), "lower_gradient")

        # Draw rectangle over background image
        rect_size = (canvas_width, padding[1])
        svg_canvas.add(svg_canvas.rect(
            insert=(0, 0), size=rect_size, fill=fg_color_hex))
        rect_size = (canvas_width, canvas_height - padding[1])
        svg_canvas.add(svg_canvas.rect(
            insert=(0, canvas_height), size=rect_size, fill=bg_color_hex))

        self._write_event_info(svg_canvas, event_information,
                               bg_color_hex, fg_color_hex, padding)

        if logo_image:
            logo = Image.open(logo_image)
            self._place_logo(svg_canvas, logo, link)

        self.save_image(svg_canvas, event_information,
                        canvas_type.name, savedir)

    def _create_file_name(self, canvas_type: str, even_information: EventInformation) -> str:
        def _safer(s: str):
            return re.sub(r'[^A-Za-z0-9.._-]', '_', s)
        return f"{_safer(even_information.title[0])}_{_safer(even_information.date[0])}_{_safer(canvas_type)}"

    def save_image(self, canvas: svgwrite.Drawing, even_information: EventInformation, canvas_type: str, save_path: str):
        canvas.save(pretty=True)

        # TODO: Save to pdf and png somehow. Fix font embedding.
        # file_name = self._create_file_name(canvas_type, even_information)
        # file_path = Path(save_path).resolve() / file_name
        # file_path_svg = f"{file_path}.svg"
        # width = float(canvas.attribs["width"])
        # height = float(canvas.attribs["height"])


def main(args: Namespace):
    postmaker = PostMaker()

    background_image = None

    if args.background:
        background_image = Path(args.background)
        try:
            # TODO: Change this to not include pillow
            Image.open(background_image.absolute())
        except:
            raise ValueError("Arkaplan için girilen dosya bir resim değil!")

    logo_image = None
    if args.logo:
        logo_image = Path(args.logo)
        try:
            Image.open(logo_image.absolute())
        except:
            raise ValueError("Logo için girilen dosya bir resim değil!")

    event_information = EventInformation(
        title=(args.title, args.title_font, args.title_size),
        desc=(args.description, args.description_font, args.description_size),
        date=(args.date, args.date_font, args.date_size),
        place=(args.place, args.place_font, args.place_size),
    )

    if args.canvas:
        postmaker.create(Posts[args.canvas], args.bgcolor,
                         args.fgcolor, event_information, args.link, background_image, logo_image, args.savedir)
    else:
        for canvas_type in Posts:
            postmaker.create(canvas_type, args.bgcolor,
                             args.fgcolor, event_information, args.link, background_image, logo_image, args.savedir)
    return


if __name__ == "__main__":
    parser = ArgumentParser(description="Sosyal medya için post hazırlayıcı.")
    parser.add_argument(
        "--canvas", "-c",
        type=str,
        choices=["IG_POST", "IG_STORY", "IG_REELS",
                 "FB_POST", "FB_STORY", "FB_REELS", "X_POST"]
    )
    parser.add_argument(
        "--background", "-bg",
        type=str,
        help="Logo resminin bilgisayardaki konumu"
    )
    parser.add_argument(
        "--logo", "-l",
        type=str,
        help="Arka plan resminin bilgisayardaki konumu"
    )
    parser.add_argument(
        "--bgcolor", "-bgc",
        type=str,
        default="#ffffff",
        help="Arka plan rengi"
    )
    parser.add_argument(
        "--fgcolor", "-fgc",
        type=str,
        default="#eb4034",
        help="Ön plan rengi"
    )
    parser.add_argument(
        "--place", "-p",
        type=str,
        default="Place: Not decided yet",
        help="Etkinliğin yapılacağı mekan"
    )
    parser.add_argument(
        "--place_font", "-pf",
        type=str,
        default="PlaceholderFont",
        help="Mekanın fontu"
    )
    parser.add_argument(
        "--place_size", "-ps",
        type=int,
        default=75,
        help="Mekanın font boyutu"
    )
    parser.add_argument(
        "--date", "-da",
        type=str,
        default="Date: Not decided yet",
        help="Etkinliğin yapılacağı zaman"
    )
    parser.add_argument(
        "--date_font", "-daf",
        type=str,
        default="PlaceholderFont",
        help="Zamanın fontu"
    )
    parser.add_argument(
        "--date_size", "-das",
        type=int,
        default=60,
        help="Zamanın font boyutu"
    )
    parser.add_argument(
        "--title", "-t",
        type=str,
        default="Title: Not decided yet",
        help="Etkinliğin başlığı"
    )
    parser.add_argument(
        "--title_font", "-tf",
        type=str,
        default="PlaceholderFont",
        help="Başlığın fontu"
    )
    parser.add_argument(
        "--title_size", "-ts",
        type=int,
        default=100,
        help="Başlığın font boyutu"
    )
    parser.add_argument(
        "--description", "-desc",
        type=str,
        default="Description: Not decided yet",
        help="Etkinliğin açıklaması"
    )
    parser.add_argument(
        "--description_font", "-descf",
        type=str,
        default="PlaceholderFont",
        help="Açıklamanın fontu"
    )
    parser.add_argument(
        "--description_size", "-descs",
        type=int,
        default=54,
        help="Açıklamanın font boyutu"
    )
    parser.add_argument(
        "--savedir", "-sd",
        type=str,
        default=".",
        help="Dosyaların kaydedileceği yer"
    )
    parser.add_argument(
        "--link", "-li",
        type=str,
        default="PlaceholderLink",
        help="QR kodu oluşturulacak olan link"
    )
    args = parser.parse_args()
    main(args)
