from enum import Enum
from PIL import ImageDraw, ImageOps, Image, ImageColor
from argparse import ArgumentParser, Namespace
from pathlib import Path
from dataclasses import dataclass
import re
import qrcode
from qrcode.constants import ERROR_CORRECT_M
from io import BytesIO
from reportlab.pdfgen import canvas as c
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.pdfmetrics import stringWidth
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib.colors import HexColor
from reportlab.lib.utils import ImageReader
from typing import Callable
from pdf2image import convert_from_path


@dataclass
class EventInformation():
    title: tuple[str, str, int]
    desc: tuple[str, str, int]
    place: tuple[str, str, int]
    date: tuple[str, str, int]


@dataclass
class PostInformation():
    width: int
    height: int
    text_padding: int
    x_padding: int
    y_padding: int


class Posts(Enum):
    IG_POST = PostInformation(width=1080, height=1350,
                              text_padding=55, x_padding=0, y_padding=135)
    IG_STORY = PostInformation(
        width=1080, height=1920, text_padding=55, x_padding=100, y_padding=120)
    IG_REELS = PostInformation(
        width=1080, height=1920, text_padding=55, x_padding=0, y_padding=0)
    FB_POST = PostInformation(width=1200, height=1200,
                              text_padding=55, x_padding=0, y_padding=0)
    FB_STORY = PostInformation(
        width=1080, height=1920, text_padding=55, x_padding=100, y_padding=120)
    FB_REELS = PostInformation(
        width=1080, height=1920, text_padding=55, x_padding=0, y_padding=0)
    X_POST = PostInformation(width=1200, height=675,
                             text_padding=55, x_padding=0, y_padding=0)


class PostMaker():

    def _get_padding(self, canvas_type: Posts | PostInformation) -> tuple[int, int, int]:
        if isinstance(canvas_type, Posts):
            canvas_type = canvas_type.value
        return (canvas_type.x_padding, canvas_type.y_padding, canvas_type.text_padding)

    def _place_bg_image(self, canvas: c.Canvas, bg_image: Path, padding: tuple[int, int] | tuple[int, int, int]):
        c_width, c_height = canvas._pagesize
        desired_size = (c_width, c_height - (2 * padding[1]))
        image = Image.open(bg_image)
        image = image.copy()
        image = ImageOps.fit(image, desired_size)
        canvas.drawInlineImage(image, 0, padding[1])

    # This function was generated by AI
    def _generate_qr(self, qr: str,
                     size: tuple[int, int] = (300, 300),
                     *,
                     fill: str = "black",
                     back: str = "white",
                     error=ERROR_CORRECT_M,
                     border: int = 4,
                     box_size: int = 10) -> Image.Image:

        qr = qrcode.QRCode(
            version=None,
            error_correction=error,
            box_size=box_size,
            border=border,
        )
        qr.add_data(qr)
        qr.make(fit=True)

        img = qr.make_image(fill_color=fill, back_color=back).convert("RGB")

        img = img.resize(size, Image.NEAREST)
        return img

    def _convert_image_to_bytes(self, image: Image.Image | Path) -> bytes:
        if isinstance(image, Path):
            img = image.resolve()
            return img.read_bytes()
        else:
            buffer = BytesIO()
            image.save(buffer, format="PNG")
            return buffer.getvalue()

    def _place_logo(self, canvas: c.Canvas, logo_image: Image.Image, qr: str):
        c_width, c_height = canvas._pagesize
        if qr != "PlaceholderLink":
            qr_image = self._generate_qr(qr, logo_image.size)
            temp_canvas = Image.new(
                "RGBA", ((logo_image.width*2), logo_image.height))
            temp_canvas.paste(logo_image, (logo_image.width, 0))
            temp_canvas.paste(qr_image, (0, 0))
            logo_image = temp_canvas
        if not self.place_bbox or not self.date_bbox:
            desired_size = (c_width//5, int(c_height//5.4))
        else:
            x_space = c_width - 10 - \
                int(max(self.date_bbox["x"] + self.date_bbox["width"],
                    self.place_bbox["x"] + self.place_bbox["width"]))
            inverse_ratio = logo_image.height/logo_image.width
            y_space = self.place_bbox["height"] + self.place_bbox["y"]
            if y_space/x_space < inverse_ratio:
                x_space = int((1/inverse_ratio) * y_space)

            y_space = x_space * inverse_ratio
            desired_size = (x_space, int(y_space))

        dw, dh = desired_size
        resized_logo_image = ImageOps.cover(logo_image, desired_size)

        resized_logo_image_bytes = self._convert_image_to_bytes(
            resized_logo_image)
        buffer = BytesIO(resized_logo_image_bytes)
        buffer.seek(0)
        logo = ImageReader(buffer)
        canvas.drawImage(logo, c_width - resized_logo_image.width,
                         0, width=dw, height=dh, mask='auto')

    def _register_font(self, font_path: str | Path) -> str:

        font_path = Path(font_path)
        font_name = font_path.stem.replace(' ', '_')
        pdfmetrics.registerFont(TTFont(font_name, font_path.resolve()))
        return font_name

    def _write_with_box(self, canvas: c.Canvas, text: str, font_path: str | Path, text_pos: tuple[int, int],
                        color: str, font_size=20):
        text = text.replace(r'\n', '\n')
        font_name = self._register_font(font_path)
        lines = text.splitlines()

        ascent = pdfmetrics.getAscent(font_name, font_size)
        descent = pdfmetrics.getDescent(font_name, font_size)
        line_height_px = ascent - descent

        canvas.saveState()
        x, y_bottom = text_pos
        canvas.setFillColor(HexColor(color))
        canvas.setFont(font_name, font_size)

        y_top = y_bottom - descent
        first_line = lines[0]
        for line in reversed(lines):
            canvas.drawString(x, y_top, line)
            if line == first_line:
                y_top += ascent
            else:
                y_top += line_height_px

        canvas.restoreState()

    def _get_bbox(self, text: str, font_path: str | Path, font_size: float, loc: tuple[float, float]) -> dict[str, float]:
        ''' Always below descent amount of pixels of the specified location. You can use the same function with location (0,0) to find it out.'''
        font_name = self._register_font(font_path)
        text = text.replace(r'\n', '\n')
        lines = text.splitlines()
        line_count = len(lines)
        x, y = loc
        width = stringWidth(text, font_name, font_size)
        ascent = pdfmetrics.getAscent(font_name, font_size)
        descent = pdfmetrics.getDescent(font_name, font_size)
        line_height = ascent - descent

        width = max(stringWidth(line, font_name, font_size) for line in lines)

        height = line_count * line_height

        y += descent
        return {
            "x": x,
            "y": y,
            "width": width,
            "height": height,
            "ascent": ascent,
            "descent": descent
        }

    def _write_event_info(self, canvas: c.Canvas, event_info: EventInformation, color_1: str, color_2: str, padding: tuple[int, int, int]):
        title, title_font, title_size = event_info.title
        place, place_font, place_size = event_info.place
        date, date_font, date_size = event_info.date
        desc, desc_font, desc_size = event_info.desc
        _, canvas_height = canvas._pagesize
        x_padding, y_padding, text_padding = padding
        left_padding = x_padding

        # Title preloc
        title_bbox = self._get_bbox(title, title_font, title_size, (0, 0))
        title_y = canvas_height - (y_padding + title_bbox["height"])
        title_loc = (left_padding, title_y)
        self.title_bbox = self._get_bbox(
            title, title_font, title_size, title_loc)

        # Desc preloc
        description_bbox = self._get_bbox(desc, desc_font, desc_size, (0, 0))
        desc_y = int(self.title_bbox["y"] -
                     description_bbox["height"] - description_bbox["descent"] - text_padding)
        desc_loc = (left_padding, desc_y)
        self.description_bbox = self._get_bbox(
            desc, desc_font, desc_size, desc_loc)

        # Date preloc
        date_loc = (left_padding, y_padding)
        self.date_bbox = self._get_bbox(date, date_font, date_size, date_loc)

        # Place preloc
        place_bbox = self._get_bbox(
            place, place_font, place_size, (0, 0))
        place_loc = (
            left_padding, self.date_bbox["y"] + self.date_bbox["height"] - place_bbox["descent"] + text_padding)
        self.place_bbox = self._get_bbox(
            place, place_font, place_size, place_loc)

        title_pos = (int(self.title_bbox["x"]), int(self.title_bbox["y"]))
        desc_pos = (int(self.description_bbox["x"]), int(
            self.description_bbox["y"]))
        date_pos = (int(self.date_bbox["x"]), int(self.date_bbox["y"]))
        place_pos = (int(self.place_bbox["x"]), int(self.place_bbox["y"]))

        # Title
        self._write_with_box(canvas, title, title_font,
                             title_pos, color_1, font_size=title_size)
        # Description
        self._write_with_box(canvas, desc, desc_font,
                             desc_pos, color_1, font_size=desc_size)
        # Place
        self._write_with_box(canvas, place, place_font,
                             place_pos, color_2, font_size=place_size)
        # Date
        self._write_with_box(canvas, date, date_font,
                             date_pos, color_2, font_size=date_size)

    def _create_cubic_bezier(self, p1: float, p2: float, p3: float, p4: float) -> Callable[[float], float]:
        return lambda t: p1*(1-t)**3 + t*3*p2*(1-t)**2 + (t**2)*p3*(1-t)*3 + p4*t**3

    def _apply_gradient(self, canvas: c.Canvas, color: str, start: tuple[int, int], end: tuple[int, int]) -> None:
        c_width, _ = canvas._pagesize
        color_values = ImageColor.getrgb(color)
        gradient_size = (c_width, max(
            start[1], end[1]) - min(start[1], end[1]))

        gradient_image = Image.new("RGBA", gradient_size)
        draw = ImageDraw.Draw(gradient_image)

        # TODO: convert to numpy
        # chosen with https://cubic-bezier.com/
        ease = self._create_cubic_bezier(0, .7, .9, 1)
        for i in range(gradient_size[1]+1):
            p = 1 - (i/gradient_size[1])
            eased = ease(p)
            alpha = int(255 * eased)
            draw.line([(0, i), (c_width, i)], fill=(
                color_values[0], color_values[1], color_values[2], alpha))

        if start[1] > end[1]:
            starty = end[1] + 2
        else:
            gradient_image = gradient_image.rotate(180)
            starty = start[1] - 2

        gradient_image_bytes = self._convert_image_to_bytes(gradient_image)
        buffer = BytesIO(gradient_image_bytes)
        buffer.seek(0)
        gradient = ImageReader(buffer)
        canvas.drawImage(gradient, 0, starty, mask='auto')

    def _place_elements(self, canvas: c.Canvas, bg_color_hex: str, fg_color_hex: str,
                        event_information: EventInformation, qr: str,
                        padding: tuple[int, int, int], bg_image: Path | None = None, logo_image: Path | None = None) -> c.Canvas:

        canvas_width, canvas_height = canvas._pagesize
        if bg_image:
            self._place_bg_image(canvas, bg_image, padding)

        # Draw rectangle over background image
        rect_size = (canvas_width, padding[1])
        bg_color = HexColor(bg_color_hex)
        canvas.setFillColor(bg_color)
        canvas.setStrokeColor(bg_color)
        canvas.rect(0, 0, rect_size[0],
                    rect_size[1], stroke=1, fill=1)
        rect_size = (canvas_width, canvas_height - padding[1])
        fg_color = HexColor(fg_color_hex)
        canvas.setFillColor(fg_color)
        canvas.setStrokeColor(fg_color)
        canvas.rect(0, canvas_height-padding[1],
                    rect_size[0], rect_size[1], stroke=1, fill=1)

        # Draw gradient over background image
        upper_space = (0, padding[1])
        lower_space = (0, canvas_height - padding[1])
        fade_length = int(canvas_height*0.6)

        self._apply_gradient(canvas, fg_color_hex,
                             lower_space, (0, canvas_height - fade_length))
        self._apply_gradient(canvas, bg_color_hex,
                             upper_space, (0, fade_length))

        self._write_event_info(canvas, event_information,
                               bg_color_hex, fg_color_hex, padding)

        if logo_image:
            logo = Image.open(logo_image)
            self._place_logo(canvas, logo, qr)

        return canvas

    def create(self, canvas_type: Posts | PostInformation, bg_color_hex: str, fg_color_hex: str,
               event_information: EventInformation, qr: str,
               bg_image: Path | None = None, logo_image: Path | None = None, savedir: str = ".") -> None:

        # TODO: Check validity of hex code
        if isinstance(canvas_type, Posts):
            canvas_type = canvas_type.value
        canvas_height = canvas_type.height
        canvas_width = canvas_type.width
        file_name = self._create_file_name(
            f"{canvas_width}x{canvas_height}", event_information)
        file_name = str(Path(savedir).resolve()/file_name)

        # TODO: fix this
        canvas = c.Canvas(
            f"{file_name}.pdf", pagesize=(canvas_width, canvas_height), pdfVersion=(1, 4))

        padding = self._get_padding(canvas_type)

        canvas = self._place_elements(canvas, bg_color_hex, fg_color_hex,
                                      event_information, qr, padding, bg_image, logo_image)

        self.save_image(canvas, file_name, (canvas_width, canvas_height))

    def _create_file_name(self, canvas_type: str, even_information: EventInformation) -> str:
        def _safer(s: str):
            return re.sub(r'[^A-Za-z0-9.._-]', '_', s)
        return f"{_safer(even_information.title[0])}_{_safer(even_information.date[0])}_{_safer(canvas_type)}"

    def save_image(self, canvas: c.Canvas, file_name: str | Path, size: tuple[int, int]) -> None:
        canvas.save()
        if not isinstance(file_name, Path):
            file_name = Path(file_name)
        images = convert_from_path(f"{file_name}.pdf", dpi=300, size=size)
        images[0].save(f"{file_name}.png", "PNG")


def main(args: Namespace):
    postmaker = PostMaker()

    background_image = None

    if args.background:
        background_image = Path(args.background)
        try:
            Image.open(background_image.absolute())
        except:
            raise ValueError("Arkaplan için girilen dosya bir resim değil!")

    logo_image = None
    if args.logo:
        logo_image = Path(args.logo)
        try:
            Image.open(logo_image.absolute())
        except:
            raise ValueError("Logo için girilen dosya bir resim değil!")

    event_information = EventInformation(
        title=(args.title, args.title_font, args.title_size),
        desc=(args.description, args.description_font, args.description_size),
        date=(args.date, args.date_font, args.date_size),
        place=(args.place, args.place_font, args.place_size),
    )

    if args.width and args.height:
        postmaker.create(PostInformation(args.width, args.height, args.text_padding, args.xpadding, args.ypadding), args.bgcolor,
                         args.fgcolor, event_information, args.qr, background_image, logo_image, args.savedir)
    elif args.canvas:
        postmaker.create(Posts[args.canvas], args.bgcolor,
                         args.fgcolor, event_information, args.qr, background_image, logo_image, args.savedir)
    else:
        for canvas_type in Posts:
            postmaker.create(canvas_type, args.bgcolor,
                             args.fgcolor, event_information, args.qr, background_image, logo_image, args.savedir)
    return


if __name__ == "__main__":
    parser = ArgumentParser(description="Sosyal medya için post hazırlayıcı.")
    parser.add_argument(
        "--canvas", "-c",
        type=str,
        choices=["IG_POST", "IG_STORY", "IG_REELS",
                 "FB_POST", "FB_STORY", "FB_REELS", "X_POST"]
    )
    parser.add_argument(
        "--background", "-bg",
        type=str,
        help="Logo resminin bilgisayardaki konumu"
    )
    parser.add_argument(
        "--logo", "-l",
        type=str,
        help="Arka plan resminin bilgisayardaki konumu"
    )
    parser.add_argument(
        "--bgcolor", "-bgc",
        type=str,
        default="#ffffff",
        help="Arka plan rengi"
    )
    parser.add_argument(
        "--fgcolor", "-fgc",
        type=str,
        default="#eb4034",
        help="Ön plan rengi"
    )
    parser.add_argument(
        "--place", "-p",
        type=str,
        default="Place: Not decided yet",
        help="Etkinliğin yapılacağı mekan"
    )
    parser.add_argument(
        "--place_font", "-pf",
        type=str,
        default="PlaceholderFont",
        help="Mekanın fontu"
    )
    parser.add_argument(
        "--place_size", "-ps",
        type=int,
        default=75,
        help="Mekanın font boyutu"
    )
    parser.add_argument(
        "--date", "-da",
        type=str,
        default="Date: Not decided yet",
        help="Etkinliğin yapılacağı zaman"
    )
    parser.add_argument(
        "--date_font", "-daf",
        type=str,
        default="PlaceholderFont",
        help="Zamanın fontu"
    )
    parser.add_argument(
        "--date_size", "-das",
        type=int,
        default=60,
        help="Zamanın font boyutu"
    )
    parser.add_argument(
        "--title", "-t",
        type=str,
        default="Title: Not decided yet",
        help="Etkinliğin başlığı"
    )
    parser.add_argument(
        "--title_font", "-tf",
        type=str,
        default="PlaceholderFont",
        help="Başlığın fontu"
    )
    parser.add_argument(
        "--title_size", "-ts",
        type=int,
        default=100,
        help="Başlığın font boyutu"
    )
    parser.add_argument(
        "--description", "-desc",
        type=str,
        default="Description: Not decided yet",
        help="Etkinliğin açıklaması"
    )
    parser.add_argument(
        "--description_font", "-descf",
        type=str,
        default="PlaceholderFont",
        help="Açıklamanın fontu"
    )
    parser.add_argument(
        "--description_size", "-descs",
        type=int,
        default=54,
        help="Açıklamanın font boyutu"
    )
    parser.add_argument(
        "--savedir", "-sd",
        type=str,
        default=".",
        help="Dosyaların kaydedileceği yer"
    )
    parser.add_argument(
        "--qr", "-li",
        type=str,
        default="PlaceholderLink",
        help="QR kodu oluşturulacak olan yazı"
    )
    parser.add_argument(
        "--width", "-w",
        type=int,
        help="Görsel'in genişliği"
    )
    parser.add_argument(
        "--height", "-he",
        type=int,
        help="Görselin yüksekliği"
    )
    parser.add_argument(
        "--xpadding", "-xp",
        type=int,
        default=0,
        help="Görselin x paddingi"
    )
    parser.add_argument(
        "--ypadding", "-yp",
        type=int,
        default=0,
        help="Görselin y paddingi"
    )
    parser.add_argument(
        "--text_padding", "-tp",
        type=int,
        default=0,
        help="Görseldeki yazılar arasındaki mesafe (px). Pre-made Canvas'lar ile çalısmaz."
    )
    args = parser.parse_args()
    main(args)
