from enum import Enum
from PIL import ImageDraw, ImageOps, ImageFont, Image, ImageColor
from argparse import ArgumentParser, Namespace
from pathlib import Path
from dataclasses import dataclass
import re
import qrcode
from qrcode.constants import ERROR_CORRECT_M
import base64
import mimetypes
from io import BytesIO
from reportlab.pdfgen import canvas as c
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.pdfmetrics import stringWidth
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib.colors import HexColor
from reportlab.lib.utils import ImageReader
from typing import Callable
from pdf2image import convert_from_path


@dataclass
class EventInformation():
    title: tuple[str, str, int]
    desc: tuple[str, str, int]
    place: tuple[str, str, int]
    date: tuple[str, str, int]


class Posts(Enum):
    IG_POST = (1080, 1350)
    IG_STORY = (1080, 1920)
    IG_REELS = (1080, 1920)
    FB_POST = (1200, 1200)
    FB_STORY = (1080, 1920)
    FB_REELS = (1080, 1920)
    X_POST = (1200, 675)


class PostMaker():

    def _get_padding(self, canvas_type: Posts) -> tuple[int, int]:
        canvas_name = canvas_type.name
        if canvas_name == "IG_STORY" or canvas_name == "FB_STORY":
            return (100, 120)
        elif canvas_name == "IG_POST":
            return (0, 135)
        else:
            return (0, 0)

    def _place_bg_image(self, canvas: c.Canvas, bg_image: Path, padding: tuple[int, int]):
        c_width, c_height = canvas._pagesize
        desired_size = (c_width, c_height - (2 * padding[1]))
        image = Image.open(bg_image)
        image = image.copy()
        image = ImageOps.fit(image, desired_size)
        canvas.drawInlineImage(image, 0, padding[1])

    # This function was generated by AI
    def _generate_qr(self, link: str,
                     size: tuple[int, int] = (300, 300),
                     *,
                     fill: str = "black",
                     back: str = "white",
                     error=ERROR_CORRECT_M,
                     border: int = 4,
                     box_size: int = 10) -> Image.Image:

        qr = qrcode.QRCode(
            version=None,
            error_correction=error,
            box_size=box_size,
            border=border,
        )
        qr.add_data(link)
        qr.make(fit=True)

        img = qr.make_image(fill_color=fill, back_color=back).convert("RGB")

        img = img.resize(size, Image.NEAREST)
        return img

    def _convert_image_to_bytes(self, image: Image.Image | Path) -> bytes:
        if isinstance(image, Path):
            img = image.resolve()
            return img.read_bytes()
        else:
            buffer = BytesIO()
            image.save(buffer, format="PNG")
            return buffer.getvalue()

    def _place_logo(self, canvas: c.Canvas, logo_image: Image.Image, link: str):
        c_width, c_height = canvas._pagesize
        if link != "PlaceholderLink":
            qr_image = self._generate_qr(link, logo_image.size)
            temp_canvas = Image.new(
                "RGBA", ((logo_image.width*2), logo_image.height))
            temp_canvas.paste(logo_image, (logo_image.width, 0))
            temp_canvas.paste(qr_image, (0, 0))
            logo_image = temp_canvas
        if not self.place_bbox or not self.date_bbox:
            desired_size = (c_width//5, int(c_height//5.4))
        else:
            x_space = c_width - 10 - \
                int(max(self.date_bbox["x"] + self.date_bbox["width"],
                    self.place_bbox["x"] + self.place_bbox["width"]))
            inverse_ratio = logo_image.height/logo_image.width
            y_space = self.place_bbox["height"] + self.place_bbox["y"]
            if y_space/x_space < inverse_ratio:
                x_space = int((1/inverse_ratio) * y_space)

            y_space = x_space * inverse_ratio
            desired_size = (x_space, int(y_space))

        dw, dh = desired_size
        resized_logo_image = ImageOps.cover(logo_image, desired_size)

        resized_logo_image_bytes = self._convert_image_to_bytes(
            resized_logo_image)
        buffer = BytesIO(resized_logo_image_bytes)
        buffer.seek(0)
        logo = ImageReader(buffer)
        canvas.drawImage(logo, c_width - resized_logo_image.width,
                         0, width=dw, height=dh, mask='auto')

    def _register_font(self, font_path: str | Path) -> str:

        font_path = Path(font_path)
        font_name = font_path.stem.replace(' ', '_')
        pdfmetrics.registerFont(TTFont(font_name, font_path.resolve()))
        return font_name

    def _write_with_box(self, canvas: c.Canvas, text: str, font_path: str | Path, tex_pos: tuple[int, int],
                        color: str, font_size=20):
        text = text.replace(r'\n', '\n').replace(r'\t', '\t')
        font_name = self._register_font(font_path)
        lines = text.splitlines()

        x, _ = tex_pos
        line_height_px = font_size * 1.0

        canvas.saveState()
        x, y = tex_pos
        canvas.setFillColor(HexColor(color))
        canvas.setFont(font_name, font_size)

        for line in lines:
            canvas.drawString(x, y, line)
            y += line_height_px
        canvas.restoreState()

    def _get_bbox(self, text: str, font_path: str | Path, font_size: float, loc: tuple[float, float]) -> dict[str, float]:
        font_name = self._register_font(font_path)
        text = text.replace(r'\n', '\n').replace(r'\t', '\t')
        lines = text.splitlines()
        line_count = len(lines)
        x, y = loc
        width = stringWidth(text, font_name, font_size)
        ascent = pdfmetrics.getAscent(font_name) * font_size / 1000.0
        descent = pdfmetrics.getDescent(font_name) * font_size / 1000.0
        line_height = ascent - descent

        width = max(stringWidth(line, font_name, font_size) for line in lines)

        height = line_count * line_height

        # canvas.rect(x, y, width, height)
        return {
            "x": x,
            "y": y - descent,
            "width": width,
            "height": height
        }

    def _write_event_info(self, canvas: c.Canvas, event_info: EventInformation, color_1: str, color_2: str, padding: tuple[int, int]):
        title, title_font, title_size = event_info.title
        place, place_font, place_size = event_info.place
        date, date_font, date_size = event_info.date
        desc, desc_font, desc_size = event_info.desc
        _, c_h = canvas._pagesize
        p_x = padding[0]
        p_y = padding[1]
        bottom_padding = p_y
        left_padding = (p_x + 55)

        # Title preloc
        title_y = c_h - (p_y + title_size)
        title_loc = (left_padding, title_y)
        self.title_bbox = self._get_bbox(
            title, title_font, title_size, title_loc)

        # Place preloc
        place_loc = (left_padding, bottom_padding + place_size)
        self.place_bbox = self._get_bbox(
            place, place_font, place_size, place_loc)

        # Date preloc
        date_bbox = self._get_bbox(date, date_font, date_size, (0, 0))
        date_loc = (left_padding, int(
            self.place_bbox["y"] - date_bbox["height"]))
        self.date_bbox = self._get_bbox(date, date_font, date_size, date_loc)

        bottom_delta = self.date_bbox["y"] - 35
        while bottom_delta < 0:
            place_loc = (left_padding, bottom_padding +
                         (self.date_bbox["y"]+self.date_bbox["height"]) + 5)
            self.place_bbox = self._get_bbox(
                place, place_font, place_size, place_loc)
            date_loc = (
                left_padding, self.place_bbox["y"] - date_bbox["height"])
            self.date_bbox = self._get_bbox(
                date, date_font, date_size, date_loc)
            bottom_delta = self.date_bbox["y"] - 35

        # Compensate for conversion between PIL and svgwrite
        date_x, date_y = date_loc
        place_x, place_y = place_loc
        compensation = 25

        # Desc preloc
        desc_y = int(self.title_bbox["y"] - title_size - compensation)
        desc_loc = (left_padding, desc_y)
        self.description_bbox = self._get_bbox(
            desc, desc_font, desc_size, desc_loc)
        # Title
        self._write_with_box(canvas, title, title_font,
                             title_loc, color_1, font_size=title_size)
        # Description
        self._write_with_box(canvas, desc, desc_font,
                             desc_loc, color_1, font_size=desc_size)
        # Place
        self._write_with_box(canvas, place, place_font,
                             (place_x, int(place_y)), color_2, font_size=place_size)
        # Date
        self._write_with_box(canvas, date, date_font,
                             (date_x, int(date_y)), color_2, font_size=date_size)

    def _create_cubic_bezier(self, p1: float, p2: float, p3: float, p4: float) -> Callable[[float], float]:
        return lambda t: p1*(1-t)**3 + t*3*p2*(1-t)**2 + (t**2)*p3*(1-t)*3 + p4*t**3

    def _apply_gradient(self, canvas: c.Canvas, color: str, start: tuple[int, int], end: tuple[int, int]) -> None:
        c_width, _ = canvas._pagesize
        color_values = ImageColor.getrgb(color)
        gradient_size = (c_width, max(
            start[1], end[1]) - min(start[1], end[1]))

        gradient_image = Image.new("RGBA", gradient_size)
        draw = ImageDraw.Draw(gradient_image)

        # TODO: convert to numpy
        # chosen with https://cubic-bezier.com/
        ease = self._create_cubic_bezier(0, .7, .9, 1)
        for i in range(gradient_size[1]+1):
            p = 1 - (i/gradient_size[1])
            eased = ease(p)
            alpha = int(255 * eased)
            draw.line([(0, i), (c_width, i)], fill=(
                color_values[0], color_values[1], color_values[2], alpha))

        if start[1] > end[1]:
            starty = end[1] + 2
        else:
            gradient_image = gradient_image.rotate(180)
            starty = start[1] - 2

        gradient_image_bytes = self._convert_image_to_bytes(gradient_image)
        buffer = BytesIO(gradient_image_bytes)
        buffer.seek(0)
        gradient = ImageReader(buffer)
        canvas.drawImage(gradient, 0, starty, mask='auto')

    def create(self, canvas_type: Posts, bg_color_hex: str, fg_color_hex: str,
               event_information: EventInformation, link: str,
               bg_image: Path | None = None, logo_image: Path | None = None, savedir: str = ".") -> None:

        # TODO: Check validity of hex code
        canvas_height = canvas_type.value[1]
        canvas_width = canvas_type.value[0]
        file_name = self._create_file_name(canvas_type.name, event_information)
        file_name = str(Path(savedir).resolve()/file_name)

        # TODO: fix this
        canvas = c.Canvas(
            f"{file_name}.pdf", pagesize=(canvas_width, canvas_height), pdfVersion=(1, 4))

        padding = self._get_padding(canvas_type)

        if bg_image:
            self._place_bg_image(canvas, bg_image, padding)

        # Draw rectangle over background image
        rect_size = (canvas_width, padding[1])
        bg_color = HexColor(bg_color_hex)
        canvas.setFillColor(bg_color)
        canvas.setStrokeColor(bg_color)
        canvas.rect(0, 0, rect_size[0],
                    rect_size[1], stroke=1, fill=1)
        rect_size = (canvas_width, canvas_height - padding[1])
        fg_color = HexColor(fg_color_hex)
        canvas.setFillColor(fg_color)
        canvas.setStrokeColor(fg_color)
        canvas.rect(0, canvas_height-padding[1],
                    rect_size[0], rect_size[1], stroke=1, fill=1)

        # Draw gradient over background image
        upper_space = (0, padding[1])
        lower_space = (0, canvas_height - padding[1])
        fade_length = int(canvas_height*0.6)

        self._apply_gradient(canvas, fg_color_hex,
                             lower_space, (0, canvas_height - fade_length))
        self._apply_gradient(canvas, bg_color_hex,
                             upper_space, (0, fade_length))

        self._write_event_info(canvas, event_information,
                               bg_color_hex, fg_color_hex, padding)

        if logo_image:
            logo = Image.open(logo_image)
            self._place_logo(canvas, logo, link)

        self.save_image(canvas, file_name)

    def _create_file_name(self, canvas_type: str, even_information: EventInformation) -> str:
        def _safer(s: str):
            return re.sub(r'[^A-Za-z0-9.._-]', '_', s)
        return f"{_safer(even_information.title[0])}_{_safer(even_information.date[0])}_{_safer(canvas_type)}"

    def save_image(self, canvas: c.Canvas, file_name: str | Path) -> None:
        canvas.save()
        if not isinstance(file_name, Path):
            file_name = Path(file_name)
        images = convert_from_path(f"{file_name}.pdf", dpi=300)
        images[0].save(f"{file_name}.png", "PNG")


def main(args: Namespace):
    postmaker = PostMaker()

    background_image = None

    if args.background:
        background_image = Path(args.background)
        try:
            Image.open(background_image.absolute())
        except:
            raise ValueError("Arkaplan için girilen dosya bir resim değil!")

    logo_image = None
    if args.logo:
        logo_image = Path(args.logo)
        try:
            Image.open(logo_image.absolute())
        except:
            raise ValueError("Logo için girilen dosya bir resim değil!")

    event_information = EventInformation(
        title=(args.title, args.title_font, args.title_size),
        desc=(args.description, args.description_font, args.description_size),
        date=(args.date, args.date_font, args.date_size),
        place=(args.place, args.place_font, args.place_size),
    )

    if args.canvas:
        postmaker.create(Posts[args.canvas], args.bgcolor,
                         args.fgcolor, event_information, args.link, background_image, logo_image, args.savedir)
    else:
        for canvas_type in Posts:
            postmaker.create(canvas_type, args.bgcolor,
                             args.fgcolor, event_information, args.link, background_image, logo_image, args.savedir)
    return


if __name__ == "__main__":
    parser = ArgumentParser(description="Sosyal medya için post hazırlayıcı.")
    parser.add_argument(
        "--canvas", "-c",
        type=str,
        choices=["IG_POST", "IG_STORY", "IG_REELS",
                 "FB_POST", "FB_STORY", "FB_REELS", "X_POST"]
    )
    parser.add_argument(
        "--background", "-bg",
        type=str,
        help="Logo resminin bilgisayardaki konumu"
    )
    parser.add_argument(
        "--logo", "-l",
        type=str,
        help="Arka plan resminin bilgisayardaki konumu"
    )
    parser.add_argument(
        "--bgcolor", "-bgc",
        type=str,
        default="#ffffff",
        help="Arka plan rengi"
    )
    parser.add_argument(
        "--fgcolor", "-fgc",
        type=str,
        default="#eb4034",
        help="Ön plan rengi"
    )
    parser.add_argument(
        "--place", "-p",
        type=str,
        default="Place: Not decided yet",
        help="Etkinliğin yapılacağı mekan"
    )
    parser.add_argument(
        "--place_font", "-pf",
        type=str,
        default="PlaceholderFont",
        help="Mekanın fontu"
    )
    parser.add_argument(
        "--place_size", "-ps",
        type=int,
        default=75,
        help="Mekanın font boyutu"
    )
    parser.add_argument(
        "--date", "-da",
        type=str,
        default="Date: Not decided yet",
        help="Etkinliğin yapılacağı zaman"
    )
    parser.add_argument(
        "--date_font", "-daf",
        type=str,
        default="PlaceholderFont",
        help="Zamanın fontu"
    )
    parser.add_argument(
        "--date_size", "-das",
        type=int,
        default=60,
        help="Zamanın font boyutu"
    )
    parser.add_argument(
        "--title", "-t",
        type=str,
        default="Title: Not decided yet",
        help="Etkinliğin başlığı"
    )
    parser.add_argument(
        "--title_font", "-tf",
        type=str,
        default="PlaceholderFont",
        help="Başlığın fontu"
    )
    parser.add_argument(
        "--title_size", "-ts",
        type=int,
        default=100,
        help="Başlığın font boyutu"
    )
    parser.add_argument(
        "--description", "-desc",
        type=str,
        default="Description: Not decided yet",
        help="Etkinliğin açıklaması"
    )
    parser.add_argument(
        "--description_font", "-descf",
        type=str,
        default="PlaceholderFont",
        help="Açıklamanın fontu"
    )
    parser.add_argument(
        "--description_size", "-descs",
        type=int,
        default=54,
        help="Açıklamanın font boyutu"
    )
    parser.add_argument(
        "--savedir", "-sd",
        type=str,
        default=".",
        help="Dosyaların kaydedileceği yer"
    )
    parser.add_argument(
        "--link", "-li",
        type=str,
        default="PlaceholderLink",
        help="QR kodu oluşturulacak olan link"
    )
    args = parser.parse_args()
    main(args)
